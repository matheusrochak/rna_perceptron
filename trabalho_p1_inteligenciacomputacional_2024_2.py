# -*- coding: utf-8 -*-
"""Trabalho_p1_inteligenciaComputacional_2024.2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r1GyHQ3ZUp_GqEv8X3RRaRhx0x9M-oqo

EXERCICIO DE INTELIGÊNCIA COMPUTACIONAL

IMPLEMENTAÇÃO DE UMA REDE NEURAL RNA PERCEPTRON MONOCAMADA PARA RECONHECER DIGITOS '0' OU '1', UTILIZANDO UMA MATRIZ 4X4

FUNÇÃO SIGMOID E DEVIRAVDA DA SIGMOID
 DADOS DE ENTRADA  X 2 VETORES DE 16 POSIÇOES REPRESENTANDO O DIGITO 0 E 1

 SAIDA ESPERADA x
"""

def sigmoid(x):
    return 1 / (1 + np.exp(-x))  # Função Sigmoide, colocar qualquer valor entre 0 ou 1

def sigmoid_derivada(x):
    return x * (1 - x)  # Função devidada sigmoide, atualização dos pesos no treinamento

import numpy as np

# Definição das entradas
X = np.array([
    [0,1,1,0,
     1,0,0,1,
     1,0,0,1,
     0,1,1,0],  # Exemplo de dígito 0
    [0,0,1,0,
     0,1,1,0,
     0,0,1,0,
     0,0,1,0],  # Exemplo de dígito 1
])

# Saídas esperadas
y = np.array([[0], [1]])

""" PASSO: INICIALIZAÇÃO DOS PESOS


"""

pesos = np.random.uniform(-1, 1, (16, 1))  #inicialização dos pesos aleatorios

"""TREINAMNETO DO RNA"""

for epoca in range(10):  # treinamento com 10 epocas
    entrada = X # Valor de X da entrada
    soma_sinapse = np.dot(entrada, pesos)  # Multiplicação dos valores da entrada x pesos
    saida = sigmoid(soma_sinapse)  # Aplicação da função Sigmoide com valores da soma_sinapse

    erro = y - saida  # Calculo do erro
    ajustes = erro * sigmoid_derivada(saida)  # Atualização dos pesos

    pesos += np.dot(entrada.T, ajustes)  # Atualização dos novos pesos

np.save("pesos_treinados.npy", pesos)  # Salvar os pesos do treinamento

pesos = np.load("pesos_treinados.npy") # Carregar os pesos treinados

total_testes = 10
acertos = 0

for _ in range(total_testes):
    # Criamos um novo padrão aleatório entre a 0 ou 1
    if np.random.rand() > 0.6:
        novo_padrao = np.array(
            [0,1,0,0,
             1,0,0,1,
             1,0,0,1,
             0,1,0,0])   # Digito 0
        esperado = 0

    else:
        novo_padrao = np.array(
            [0,1,1,0,
             0,0,1,0,
             0,1,1,0,
             0,1,1,0])  # Digito 1
        esperado = 1

    # Passa pelo Perceptron
    saida_teste = sigmoid(np.dot(novo_padrao, pesos))

    # Classificao de 1  caso sejá maior que 0.5 senao classifica como 0
    previsao = 1 if saida_teste > 0.5 else 0

    # Conta acertos
    if previsao == esperado:
        acertos += 1
        print(f"✅ Acertou! Esperado: {esperado}, Previsão: {previsao}")
    else:
        print(f"❌ Errou! Esperado: {esperado}, Previsão: {previsao}")


# Calcula taxa de acerto
taxa_acerto = (acertos / total_testes) * 100

print(f"Total de testes: {total_testes}")
print(f"Acertos: {acertos}")
print(f"Taxa de acerto: {taxa_acerto:.2f}%")